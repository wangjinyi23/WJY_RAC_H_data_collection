import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import csv
import glob
import os
import re # For parsing TSP file
from typing import Dict, Tuple as TypingTuple
import json
import numpy as np

# Type alias for position for clarity
Position3D = TypingTuple[float, float, float]

# Removed get_initial_target_tsp_ids as it's no longer used.

def load_sensor_coordinates(json_path: str) -> Dict[int, Position3D]:
    """
    Loads sensor coordinates from a JSON file.
    """
    try:
        with open(json_path, 'r') as f:
            data = json.load(f)
            # Convert keys to int and values to tuples
            return {int(k): tuple(v) for k, v in data.items()}
    except FileNotFoundError:
        print(f"Error: Sensor locations JSON file not found: {json_path}")
        return {}
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from {json_path}")
        return {}


def plot_uav_trajectories():
    fig = plt.figure(figsize=(14, 12))
    ax = fig.add_subplot(111, projection='3d')

    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.join(script_dir, "..", "..")

    # Load ALL sensor locations (including GS if present with ID 0)
    locations_path = os.path.join(project_root, "showcases/Simulating_a_data_collection_scenario/sensor_locations_forest.json") # Ensure this matches main.py
    all_sensor_locations_with_gs = load_sensor_coordinates(locations_path)
    if not all_sensor_locations_with_gs:
        print("Error: No sensor locations loaded.")
        return

    # Load sensor categories generated by main.py
    plot_categories_path = os.path.join(script_dir, "plot_categories.json")
    sensor_plot_categories = {}
    try:
        with open(plot_categories_path, 'r') as f:
            sensor_plot_categories = json.load(f) # Keys are string TSP IDs
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"Error: Could not load or parse {plot_categories_path}: {e}")
        print("Please ensure main.py has run successfully and generated this file.")
        return

    # Separate GS and actual sensors for iteration
    ground_station_pos = all_sensor_locations_with_gs.pop(0, (250, 250, 0)) # Default GS pos if ID 0 not found
    sensor_locations_for_iteration = all_sensor_locations_with_gs # Now GS is removed

    # Define new sensor category dictionaries based on plot_categories.json
    initial_active_sensors_cat = {}
    dynamic_newly_active_sensors_cat = {}
    dynamic_deactivated_explicit_sensors_cat = {}
    dynamic_deactivated_implicit_sensors_cat = {}
    other_standby_sensors_cat = {}
    # OTHER_RAW sensors will be ignored for plotting

    for tsp_id, pos in sensor_locations_for_iteration.items():
        category_str = sensor_plot_categories.get(str(tsp_id)) # Get category from loaded file

        if category_str == "INITIAL_ACTIVE":
            initial_active_sensors_cat[tsp_id] = pos
        elif category_str == "DYNAMIC_NEWLY_ACTIVE":
            dynamic_newly_active_sensors_cat[tsp_id] = pos
        elif category_str == "DYNAMIC_DEACTIVATED_EXPLICIT":
            dynamic_deactivated_explicit_sensors_cat[tsp_id] = pos
        elif category_str == "DYNAMIC_DEACTIVATED_IMPLICIT":
            dynamic_deactivated_implicit_sensors_cat[tsp_id] = pos
        elif category_str == "OTHER_STANDBY":
            other_standby_sensors_cat[tsp_id] = pos
        elif category_str == "OTHER_RAW":
            pass # Do not plot
        elif category_str == "UNKNOWN":
             print(f"Warning: TSP ID {tsp_id} has UNKNOWN category from plot_categories.json. Not plotting.")
        else:
            print(f"Warning: TSP ID {tsp_id} has unrecognized category '{category_str}' from plot_categories.json. Not plotting.")
            
    # --- DEBUG: Print counts for each category ---
    print("\n--- Sensor Category Counts (from plot_categories.json) ---")
    print(f"Initial Active Sensors: {len(initial_active_sensors_cat)}")
    print(f"Dynamic Newly Activated Sensors: {len(dynamic_newly_active_sensors_cat)}")
    print(f"Dynamic Deactivated (Explicit): {len(dynamic_deactivated_explicit_sensors_cat)}")
    print(f"Dynamic Deactivated (Implicit): {len(dynamic_deactivated_implicit_sensors_cat)}")
    print(f"Other Standby Sensors: {len(other_standby_sensors_cat)}")
    print("--- End Sensor Category Counts ---\n")
    # --- END DEBUG ---

    # Plotting sensors based on categories from plot_categories.json
    if dynamic_deactivated_explicit_sensors_cat:
        xs, ys, zs = zip(*dynamic_deactivated_explicit_sensors_cat.values())
        ax.scatter(xs, ys, zs, color='red', marker='X', s=100, label='Activated -> Standby (Dynamic Event)')

    if dynamic_deactivated_implicit_sensors_cat: # New plot
        xs, ys, zs = zip(*dynamic_deactivated_implicit_sensors_cat.values())
        ax.scatter(xs, ys, zs, color='darkorange', marker='x', s=70, label='Activated -> Standby (Unserviced)')
        
    if initial_active_sensors_cat: # New plot
        xs, ys, zs = zip(*initial_active_sensors_cat.values())
        ax.scatter(xs, ys, zs, color='green', marker='o', s=60, edgecolor='black', label='Initial Active Sensors')

    if dynamic_newly_active_sensors_cat: # New plot
        xs, ys, zs = zip(*dynamic_newly_active_sensors_cat.values())
        ax.scatter(xs, ys, zs, color='cyan', marker='P', s=70, edgecolor='black', label='Dynamic Newly Activated')
        
    # if other_standby_sensors_cat:
    #     xs, ys, zs = zip(*other_standby_sensors_cat.values())
    #     ax.scatter(xs, ys, zs, color='gray', marker='s', s=40, label='Other Standby Sensors')
    # #     plot_raw_pos = [pos for tsp_id, pos in raw_sensors.items() if tsp_id not in highlight_red_tsp_ids]
    # #     if plot_raw_pos:
    # #         xs, ys, zs = zip(*plot_raw_pos)
    # #         # Plot RAW sensors with a distinct marker/color, e.g., purple squares
    # #         ax.scatter(xs, ys, zs, color='purple', marker='s', s=30, label='RAW Sensors')

    # Plot ground station
    ax.scatter(ground_station_pos[0], ground_station_pos[1], ground_station_pos[2],
               color='black', marker='^', s=150, label='Ground Station')

    # Find and plot all UAV trajectory CSV files
    csv_files = glob.glob(os.path.join(script_dir, "uav_*_trajectory.csv"))
    if not csv_files:
        print(f"No UAV trajectory CSV files found in {script_dir}")
    
    # Sort files to ensure a consistent plotting order (e.g., initial path first)
    csv_files.sort()

    # Collect coordinates for auto-scaling from all elements that will be plotted
    plot_points_for_scaling = [ground_station_pos]
    
    # Add points from all plotted sensor categories
    sensor_categories_for_scaling = [
        dynamic_deactivated_explicit_sensors_cat.values(),
        dynamic_deactivated_implicit_sensors_cat.values(),
        initial_active_sensors_cat.values(),
        dynamic_newly_active_sensors_cat.values(),
        # other_standby_sensors_cat.values() # No longer plotting these
    ]

    for category_values in sensor_categories_for_scaling:
        if category_values: # Check if the dictionary for this category was populated
            plot_points_for_scaling.extend(list(category_values))


    # Initialize all_x, all_y, all_z for scaling from these points
    # These names are reused for trajectory points later, which is fine.
    if plot_points_for_scaling: # Ensure there's at least GS
        all_x_coords, all_y_coords, all_z_coords = zip(*plot_points_for_scaling)
        all_x_coords = list(all_x_coords) # Convert tuple to list to allow extend
        all_y_coords = list(all_y_coords)
        all_z_coords = list(all_z_coords)
    else: # Should not happen if GS is always there
        all_x_coords, all_y_coords, all_z_coords = [], [], []


    for i, filename in enumerate(csv_files):
        try:
            with open(filename, 'r') as csvfile:
                reader = csv.reader(csvfile)
                header = next(reader)
                
                # Determine column indices
                try:
                    x_idx, y_idx, z_idx = header.index('x'), header.index('y'), header.index('z')
                except ValueError:
                    print(f"Warning: CSV file {filename} has missing x, y, or z columns.")
                    continue

                x_coords, y_coords, z_coords = [], [], []
                for row in reader:
                    try:
                        x_coords.append(float(row[x_idx]))
                        y_coords.append(float(row[y_idx]))
                        z_coords.append(float(row[z_idx]))
                    except (ValueError, IndexError):
                        continue
                
                if x_coords: # Check if any coordinates were actually read from CSV
                    all_x_coords.extend(x_coords)
                    all_y_coords.extend(y_coords)
                    all_z_coords.extend(z_coords)
                    
                    # Distinguish between initial and replanned trajectories
                    if "initial" in filename:
                        label = 'Initial UAV Trajectory'
                        color = 'blue'
                    elif "replan" in filename:
                        label = 'Replanned UAV Trajectory'
                        color = 'red'
                    else:
                        # Fallback for other files
                        uav_id_match = re.search(r'uav_(\d+)_trajectory.csv', os.path.basename(filename))
                        uav_id = uav_id_match.group(1) if uav_id_match else f"UAV {i+1}"
                        label = f'UAV {uav_id} Trajectory'
                        color = plt.cm.viridis(i / len(csv_files))

                    ax.plot(x_coords, y_coords, z_coords, label=label, color=color)

        except Exception as e:
            print(f"Error processing file {filename}: {e}")

    # Auto-scaling plot limits
    if all_x_coords: # Check if there are any points to scale against
        min_x, max_x = min(all_x_coords), max(all_x_coords)
        min_y, max_y = min(all_y_coords), max(all_y_coords)
        min_z, max_z = min(all_z_coords), max(all_z_coords)
        
        # Add a small buffer to avoid points exactly on the edge,
        # or handle cases where min and max are the same (single point or all points collinear)
        x_buffer = (max_x - min_x) * 0.1 if (max_x - min_x) > 1e-6 else 1.0
        y_buffer = (max_y - min_y) * 0.1 if (max_y - min_y) > 1e-6 else 1.0
        z_buffer = (max_z - min_z) * 0.1 if (max_z - min_z) > 1e-6 else 1.0

        ax.set_xlim(min_x - x_buffer, max_x + x_buffer)
        ax.set_ylim(min_y - y_buffer, max_y + y_buffer)
        ax.set_zlim(min_z - z_buffer, max_z + z_buffer)
    else:
        # Default limits if no points are found (e.g., only GS at origin)
        ax.set_xlim(-10, 10)
        ax.set_ylim(-10, 10)
        ax.set_zlim(-10, 10)

    ax.set_xlabel('X Coordinate')
    ax.set_ylabel('Y Coordinate')
    ax.set_zlabel('Z Coordinate')
    ax.set_title('UAV Trajectories and Sensor Network')
    ax.legend()
    plt.tight_layout()
    plt.savefig('showcases/Simulating_a_data_collection_scenario/trajectories.png')

if __name__ == '__main__':
    # The script now reads configuration from JSON files directly,
    # so command-line arguments for scenario and num_sensors are no longer needed.
    plot_uav_trajectories()