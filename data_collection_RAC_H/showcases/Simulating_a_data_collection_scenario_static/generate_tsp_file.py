import random
import argparse
import os

def generate_tsp_coordinates(num_nodes: int, min_coord: int, max_coord: int, base_station_coord: tuple = (100, 100, 0)) -> dict:
    """
    Generates random 2D coordinates for a given number of nodes.
    Node 1 is fixed as the base station.
    Z coordinate defaults to 0 for other nodes.
    """
    coordinates = {}
    if num_nodes <= 0:
        return coordinates

    # Node 1 is the base station
    coordinates[1] = base_station_coord

    # Generate coordinates for other nodes
    for i in range(2, num_nodes + 1):
        x = random.randint(min_coord, max_coord)
        y = random.randint(min_coord, max_coord)
        z = 0  # Default Z coordinate for other sensors
        coordinates[i] = (x, y, z)
    return coordinates

def write_tsp_file(filepath: str, num_nodes: int, coordinates: dict, name: str = "DefaultTSPName", comment: str = "Generated TSP File"):
    """
    Writes the node coordinates to a .tsp file.
    """
    with open(filepath, 'w') as f:
        f.write(f"NAME: {name}\n")
        f.write(f"TYPE: TSP\n")
        f.write(f"COMMENT: {comment}\n")
        f.write(f"DIMENSION: {num_nodes}\n")
        f.write(f"EDGE_WEIGHT_TYPE: EUC_2D\n") # Or specify if 3D coordinates are used differently
        f.write(f"NODE_COORD_SECTION\n")
        for node_id, (x, y, z) in coordinates.items():
            # TSP format typically uses integer node IDs and space-separated coords.
            # For EUC_2D, only x and y are strictly needed, but we can include z if desired,
            # though standard parsers might ignore it for EUC_2D.
            # Let's stick to the common EUC_2D format which expects 2D points.
            # If Z is always 0, we can just write x and y.
            # However, the existing parser in simple_protocol.py can handle an optional Z.
            f.write(f"{node_id} {x} {y} {z}\n")
        f.write("EOF\n")
    print(f"Successfully generated TSP file: {filepath}")

def main():
    parser = argparse.ArgumentParser(description="Generate a .tsp file with random node coordinates.")
    parser.add_argument("num_nodes", type=int, help="Number of nodes to generate.")
    parser.add_argument("output_file", type=str, help="Path to the output .tsp file.")
    parser.add_argument("--min_coord", type=int, default=0, help="Minimum value for X and Y coordinates (inclusive).")
    parser.add_argument("--max_coord", type=int, default=100, help="Maximum value for X and Y coordinates (inclusive).")
    parser.add_argument("--name", type=str, default=None, help="Name for the TSP instance (defaults to filename without extension).")
    parser.add_argument("--comment", type=str, default="Generated by generate_tsp_file.py", help="Comment for the TSP file.")

    args = parser.parse_args()

    if args.min_coord >= args.max_coord:
        print("Error: min_coord must be less than max_coord.")
        return

    if args.num_nodes < 1: # Must have at least the base station
        print("Error: Number of nodes must be at least 1 (for the base station).")
        return

    coordinates = generate_tsp_coordinates(args.num_nodes, args.min_coord, args.max_coord)
    
    tsp_name = args.name
    if tsp_name is None:
        tsp_name = os.path.splitext(os.path.basename(args.output_file))[0]

    write_tsp_file(args.output_file, args.num_nodes, coordinates, name=tsp_name, comment=args.comment)

if __name__ == "__main__":
    main()